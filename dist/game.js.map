{
  "version": 3,
  "sources": ["cdn-global:modu-engine", "../src/game.ts", "../src/constants.ts", "../src/entities.ts", "../src/systems.ts", "../src/render.ts"],
  "sourcesContent": ["module.exports = window.Modu;", "import { dSqrt, dRandom } from 'modu-engine';\n/**\r\n * Cell Eater - Agar.io style multiplayer game\r\n *\r\n * Build auto-transforms: dSqrt() -> dSqrt(), dRandom() -> dRandom()\r\n */\r\n\r\nimport * as modu from 'modu-engine';\r\nimport { WORLD_WIDTH, WORLD_HEIGHT, FOOD_COUNT } from './constants';\r\nimport { defineEntities } from './entities';\r\nimport {\r\n    setupSystems,\r\n    setupCollisions,\r\n    spawnFood,\r\n    spawnCell,\r\n    getPlayerCells,\r\n    cellMergeFrame,\r\n} from './systems';\r\nimport { createRenderer } from './render';\r\n\r\n// Game state\r\nlet game: modu.Game;\r\nlet renderer: modu.Simple2DRenderer;\r\nlet physics: modu.Physics2DSystem;\r\nlet input: modu.InputPlugin;\r\nlet cameraSystem: modu.CameraSystem;\r\nlet cameraEntity: modu.Entity;\r\n\r\nlet canvas: HTMLCanvasElement;\r\nlet minimapCanvas: HTMLCanvasElement;\r\nlet sizeDisplay: HTMLElement;\r\nlet WIDTH: number;\r\nlet HEIGHT: number;\r\n\r\nlet mouseX: number;\r\nlet mouseY: number;\r\n\r\nfunction getLocalClientId(): number | null {\r\n    const clientId = game.localClientId;\r\n    if (!clientId || typeof clientId !== 'string') return null;\r\n    return game.internClientId(clientId);\r\n}\r\n\r\nfunction setupInput(): void {\r\n    mouseX = WIDTH / 2;\r\n    mouseY = HEIGHT / 2;\r\n\r\n    canvas.addEventListener('mousemove', (e) => {\r\n        const rect = canvas.getBoundingClientRect();\r\n        mouseX = e.clientX - rect.left;\r\n        mouseY = e.clientY - rect.top;\r\n    });\r\n\r\n    input.action('target', {\r\n        type: 'vector',\r\n        bindings: [() => {\r\n            // Convert screen coordinates to world coordinates using camera\r\n            const cam = cameraEntity.get(modu.Camera2D);\r\n            const worldX = (mouseX - WIDTH / 2) / cam.zoom + cam.x;\r\n            const worldY = (mouseY - HEIGHT / 2) / cam.zoom + cam.y;\r\n            return { x: worldX, y: worldY };\r\n        }]\r\n    });\r\n\r\n    input.action('split', {\r\n        type: 'button',\r\n        bindings: ['key: ']\r\n    });\r\n}\r\n\r\nexport function initGame(): void {\r\n    canvas = document.getElementById('game') as HTMLCanvasElement;\r\n    minimapCanvas = document.getElementById('minimap') as HTMLCanvasElement;\r\n    sizeDisplay = document.getElementById('size-display')!;\r\n    WIDTH = canvas.width;\r\n    HEIGHT = canvas.height;\r\n\r\n    game = modu.createGame();\r\n    renderer = game.addPlugin(modu.Simple2DRenderer, canvas);\r\n    physics = game.addPlugin(modu.Physics2DSystem, { gravity: { x: 0, y: 0 } });\r\n    input = game.addPlugin(modu.InputPlugin, canvas);\r\n    cameraSystem = game.addPlugin(modu.CameraSystem);\r\n\r\n    // Expose for debugging\r\n    (window as any).game = game;\r\n\r\n    defineEntities(game);\r\n    setupCollisions(game, physics);\r\n    setupSystems(game);\r\n\r\n    // Create camera entity and set it on renderer\r\n    cameraEntity = game.spawn('camera');\r\n    const cam = cameraEntity.get(modu.Camera2D);\r\n    cam.x = WORLD_WIDTH / 2;\r\n    cam.y = WORLD_HEIGHT / 2;\r\n    renderer.camera = cameraEntity;\r\n\r\n    setupInput();\r\n\r\n    renderer.render = createRenderer(\r\n        game,\r\n        renderer,\r\n        cameraEntity,\r\n        canvas,\r\n        minimapCanvas,\r\n        sizeDisplay,\r\n        getLocalClientId\r\n    );\r\n\r\n    game.connect('cell-eater-ecs', {\r\n        onRoomCreate() {\r\n            console.log('[cell-eater] onRoomCreate');\r\n            for (let i = 0; i < FOOD_COUNT; i++) spawnFood(game);\r\n        },\r\n        onConnect(clientId: string) {\r\n            console.log('[cell-eater] onConnect:', clientId);\r\n            spawnCell(game, clientId);\r\n\r\n            if (clientId === game.localClientId) {\r\n                const player = game.getEntityByClientId(clientId);\r\n                if (player) {\r\n                    const t = player.get(modu.Transform2D);\r\n                    const cam = cameraEntity.get(modu.Camera2D);\r\n                    cam.x = t.x;\r\n                    cam.y = t.y;\r\n                }\r\n            }\r\n        },\r\n        onDisconnect(clientId: string) {\r\n            console.log('[cell-eater] onDisconnect:', clientId);\r\n            const internedId = game.internClientId(clientId);\r\n            for (const cell of getPlayerCells(game, internedId)) {\r\n                cell.destroy();\r\n                cellMergeFrame.delete(cell.id);\r\n            }\r\n        }\r\n    });\r\n\r\n    modu.enableDebugUI(game);\r\n}\r\n\r\n// Auto-init when DOM is ready\r\nif (document.readyState === 'loading') {\r\n    document.addEventListener('DOMContentLoaded', initGame);\r\n} else {\r\n    initGame();\r\n}\r\n", "/**\r\n * Cell Eater - Game Constants\r\n */\r\n\r\n// World dimensions\r\nexport const WORLD_WIDTH = 6000;\r\nexport const WORLD_HEIGHT = 6000;\r\n\r\n// Zoom settings\r\nexport const BASE_ZOOM = 1.0;\r\nexport const MIN_ZOOM = 0.35;\r\nexport const ZOOM_SCALE_FACTOR = 0.004;\r\n\r\n// Movement\r\nexport const SPEED = 400;\r\n\r\n// Cell sizing\r\nexport const INITIAL_RADIUS = 20;\r\nexport const MAX_RADIUS = 200;\r\n\r\n// Eating mechanics\r\nexport const EAT_RATIO = 1.2;\r\nexport const FOOD_GROW = 0.05;\r\nexport const PLAYER_GROW = 0.3;\r\n\r\n// Food spawning\r\nexport const FOOD_COUNT = 800;\r\nexport const MAX_FOOD = 1600;\r\nexport const FOOD_SPAWN_CHANCE = 0.15;\r\n\r\n// Split mechanics\r\nexport const MIN_SPLIT_RADIUS = 15;\r\nexport const SPLIT_VELOCITY = 400;\r\nexport const SPLIT_CONTROL_DELAY = 30;\r\nexport const MAX_CELLS_PER_PLAYER = 16;\r\nexport const MERGE_DELAY_FRAMES = 600;\r\n\r\n// Color palette\r\nexport const COLORS = [\r\n    '#ff6b6b', '#ff8e72', '#ffa94d', '#ffd43b', '#a9e34b', '#69db7c',\r\n    '#38d9a9', '#3bc9db', '#4dabf7', '#748ffc', '#9775fa', '#da77f2',\r\n    '#f783ac', '#e64980', '#d6336c', '#c2255c', '#ff4500', '#32cd32',\r\n    '#1e90ff', '#ff1493', '#00ced1', '#ffa500', '#9400d3', '#00ff7f'\r\n];\r\n", "/**\r\n * Cell Eater - Entity Definitions\r\n */\r\n\r\nimport * as modu from 'modu-engine';\r\nimport { INITIAL_RADIUS } from './constants';\r\n\r\nexport function defineEntities(game: modu.Game): void {\r\n    game.defineEntity('cell')\r\n        .with(modu.Transform2D)\r\n        .with(modu.Sprite, { shape: modu.SHAPE_CIRCLE, radius: INITIAL_RADIUS, layer: 1 })\r\n        .with(modu.Body2D, { shapeType: modu.SHAPE_CIRCLE, radius: INITIAL_RADIUS, bodyType: modu.BODY_KINEMATIC })\r\n        .with(modu.Player)\r\n        .register();\r\n\r\n    game.defineEntity('food')\r\n        .with(modu.Transform2D)\r\n        .with(modu.Sprite, { shape: modu.SHAPE_CIRCLE, radius: 8, layer: 0 })\r\n        .with(modu.Body2D, { shapeType: modu.SHAPE_CIRCLE, radius: 8, bodyType: modu.BODY_STATIC })\r\n        .register();\r\n\r\n    // Camera entity - client-only (sync: false is built into Camera2D component)\r\n    game.defineEntity('camera')\r\n        .with(modu.Camera2D, { smoothing: 0.15 })\r\n        .register();\r\n}\r\n", "import { dSqrt, dRandom } from 'modu-engine';\n/**\r\n * Cell Eater - Game Systems\r\n */\r\n\r\nimport * as modu from 'modu-engine';\r\nimport { SpawnCellOptions } from './types';\r\nimport {\r\n    WORLD_WIDTH,\r\n    WORLD_HEIGHT,\r\n    SPEED,\r\n    INITIAL_RADIUS,\r\n    MAX_RADIUS,\r\n    EAT_RATIO,\r\n    FOOD_GROW,\r\n    PLAYER_GROW,\r\n    MAX_FOOD,\r\n    FOOD_SPAWN_CHANCE,\r\n    MIN_SPLIT_RADIUS,\r\n    SPLIT_VELOCITY,\r\n    SPLIT_CONTROL_DELAY,\r\n    MAX_CELLS_PER_PLAYER,\r\n    MERGE_DELAY_FRAMES,\r\n    COLORS,\r\n} from './constants';\r\n\r\n// Track merge eligibility frame for each cell\r\nexport const cellMergeFrame = new Map<number, number>();\r\nexport const cellSplitFrame = new Map<number, number>();\r\n\r\n// Helper functions\r\nfunction getClientIdStr(game: modu.Game, numericId: number): string {\r\n    return game.getClientIdString(numericId) || '';\r\n}\r\n\r\nfunction compareStrings(a: string, b: string): number {\r\n    if (a < b) return -1;\r\n    if (a > b) return 1;\r\n    return 0;\r\n}\r\n\r\nexport function getPlayerCells(game: modu.Game, clientId: number): modu.Entity[] {\r\n    const cells: modu.Entity[] = [];\r\n    for (const cell of game.query('cell')) {\r\n        if (cell.get(modu.Player).clientId === clientId && !cell.destroyed) {\r\n            cells.push(cell);\r\n        }\r\n    }\r\n    return cells;\r\n}\r\n\r\nexport function spawnFood(game: modu.Game): void {\r\n    const colorStr = COLORS[(dRandom() * COLORS.length) | 0];\r\n    const color = game.internString('color', colorStr);\r\n    game.spawn('food', {\r\n        x: 50 + (dRandom() * (WORLD_WIDTH - 100)) | 0,\r\n        y: 50 + (dRandom() * (WORLD_HEIGHT - 100)) | 0,\r\n        color\r\n    });\r\n}\r\n\r\nexport function spawnCell(game: modu.Game, clientId: string, options: SpawnCellOptions = {}): modu.Entity {\r\n    const colorStr = options.color || COLORS[(dRandom() * COLORS.length) | 0];\r\n    const color = game.internString('color', colorStr);\r\n    const radius = options.radius || INITIAL_RADIUS;\r\n\r\n    const entity = game.spawn('cell', {\r\n        x: options.x ?? (100 + (dRandom() * (WORLD_WIDTH - 200)) | 0),\r\n        y: options.y ?? (100 + (dRandom() * (WORLD_HEIGHT - 200)) | 0),\r\n        clientId,\r\n        color\r\n    });\r\n\r\n    if (options.radius) {\r\n        const sprite = entity.get(modu.Sprite);\r\n        const body = entity.get(modu.Body2D);\r\n        sprite.radius = radius;\r\n        body.radius = radius;\r\n    }\r\n\r\n    if (options.vx !== undefined || options.vy !== undefined) {\r\n        const body = entity.get(modu.Body2D);\r\n        body.vx = options.vx || 0;\r\n        body.vy = options.vy || 0;\r\n    }\r\n\r\n    return entity;\r\n}\r\n\r\nexport function setupSystems(game: modu.Game): void {\r\n    // Movement system with integrated repulsion\r\n    game.addSystem(() => {\r\n        const playerCells = new Map<number, modu.Entity[]>();\r\n        const allCells = [...game.query('cell')].sort((a, b) => a.id - b.id);\r\n\r\n        for (const cell of allCells) {\r\n            if (cell.destroyed) continue;\r\n            const cid = cell.get(modu.Player).clientId;\r\n            if (cid === undefined || cid === null) continue;\r\n            if (!playerCells.has(cid)) playerCells.set(cid, []);\r\n            playerCells.get(cid)!.push(cell);\r\n        }\r\n\r\n        // DEBUG: Log cell counts\r\n        if (game.world.frame % 60 === 0) {\r\n            for (const [cid, cells] of playerCells) {\r\n                if (cells.length > 1) console.log(`[SPLIT] cid=${cid} cells=${cells.length}`);\r\n            }\r\n        }\r\n\r\n        const repulsion = new Map<number, { vx: number; vy: number }>();\r\n        const sortedPlayers = [...playerCells.entries()].sort((a, b) =>\r\n            compareStrings(getClientIdStr(game, a[0]), getClientIdStr(game, b[0]))\r\n        );\r\n\r\n        for (const [, siblings] of sortedPlayers) {\r\n            for (const cell of siblings) {\r\n                repulsion.set(cell.id, { vx: 0, vy: 0 });\r\n            }\r\n\r\n            if (siblings.length < 2) continue;\r\n\r\n            for (let i = 0; i < siblings.length; i++) {\r\n                const cellA = siblings[i];\r\n                const tA = cellA.get(modu.Transform2D);\r\n                const sA = cellA.get(modu.Sprite);\r\n\r\n                for (let j = i + 1; j < siblings.length; j++) {\r\n                    const cellB = siblings[j];\r\n                    const tB = cellB.get(modu.Transform2D);\r\n                    const sB = cellB.get(modu.Sprite);\r\n\r\n                    const dx = tA.x - tB.x;\r\n                    const dy = tA.y - tB.y;\r\n                    const distSq = dx * dx + dy * dy;\r\n                    const minDist = sA.radius + sB.radius;\r\n                    const minDistSq = minDist * minDist;\r\n\r\n                    if (distSq < minDistSq && distSq > 1) {\r\n                        const dist = dSqrt(distSq) || 1;\r\n                        const overlap = minDist - dist;\r\n                        const pushForce = (overlap * 0.3) + 1;\r\n                        const nx = dx / dist;\r\n                        const ny = dy / dist;\r\n\r\n                        const repA = repulsion.get(cellA.id)!;\r\n                        const repB = repulsion.get(cellB.id)!;\r\n                        repA.vx += nx * pushForce;\r\n                        repA.vy += ny * pushForce;\r\n                        repB.vx -= nx * pushForce;\r\n                        repB.vy -= ny * pushForce;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        for (const [clientId, cells] of sortedPlayers) {\r\n            const playerInput = game.world.getInput(clientId);\r\n            for (const cell of cells) {\r\n                const sprite = cell.get(modu.Sprite);\r\n                const transform = cell.get(modu.Transform2D);\r\n                const body = cell.get(modu.Body2D);\r\n\r\n                let vx = 0, vy = 0;\r\n\r\n                if (playerInput?.target) {\r\n                    const dx = playerInput.target.x - transform.x;\r\n                    const dy = playerInput.target.y - transform.y;\r\n                    const distSq = dx * dx + dy * dy;\r\n                    const dist = dSqrt(distSq) || 1;\r\n\r\n                    const stopDist = sprite.radius * 0.2;\r\n                    if (dist > stopDist) {\r\n                        vx = (dx / dist) * SPEED;\r\n                        vy = (dy / dist) * SPEED;\r\n                    }\r\n                }\r\n\r\n                const rep = repulsion.get(cell.id);\r\n                if (rep) {\r\n                    vx += rep.vx;\r\n                    vy += rep.vy;\r\n                }\r\n\r\n                // Don't override velocity for recently split cells\r\n                const splitFrame = cellSplitFrame.get(cell.id) || 0;\r\n                const framesSinceSplit = game.world.frame - splitFrame;\r\n                if (framesSinceSplit > SPLIT_CONTROL_DELAY) {\r\n                    body.vx = vx;\r\n                    body.vy = vy;\r\n                }\r\n\r\n                const r = sprite.radius;\r\n                transform.x = Math.max(r, Math.min(WORLD_WIDTH - r, transform.x));\r\n                transform.y = Math.max(r, Math.min(WORLD_HEIGHT - r, transform.y));\r\n            }\r\n        }\r\n    }, { phase: 'update' });\r\n\r\n    // Food spawning system\r\n    game.addSystem(() => {\r\n        const shouldSpawn = dRandom() < FOOD_SPAWN_CHANCE;\r\n        if (shouldSpawn && game.getEntitiesByType('food').length < MAX_FOOD) {\r\n            spawnFood(game);\r\n        }\r\n    }, { phase: 'update' });\r\n\r\n    // Split system\r\n    game.addSystem(() => {\r\n        const playerCells = new Map<number, modu.Entity[]>();\r\n        const allCells = [...game.query('cell')].sort((a, b) => a.id - b.id);\r\n\r\n        for (const cell of allCells) {\r\n            if (cell.destroyed) continue;\r\n            const clientId = cell.get(modu.Player).clientId;\r\n            if (clientId === undefined || clientId === null) continue;\r\n            if (!playerCells.has(clientId)) playerCells.set(clientId, []);\r\n            playerCells.get(clientId)!.push(cell);\r\n        }\r\n\r\n        const sortedPlayers = [...playerCells.entries()].sort((a, b) =>\r\n            compareStrings(getClientIdStr(game, a[0]), getClientIdStr(game, b[0]))\r\n        );\r\n\r\n        for (const [clientId, cells] of sortedPlayers) {\r\n            const playerInput = game.world.getInput(clientId);\r\n\r\n            if (!playerInput?.split || !playerInput?.target) continue;\r\n            if (cells.length >= MAX_CELLS_PER_PLAYER) continue;\r\n\r\n            const cellsToSplit = cells\r\n                .filter(c => c.get(modu.Sprite).radius >= MIN_SPLIT_RADIUS)\r\n                .slice(0, MAX_CELLS_PER_PLAYER - cells.length);\r\n\r\n            for (const cell of cellsToSplit) {\r\n                const transform = cell.get(modu.Transform2D);\r\n                const sprite = cell.get(modu.Sprite);\r\n                const body = cell.get(modu.Body2D);\r\n                const colorStr = game.getString('color', sprite.color);\r\n\r\n                const dx = playerInput.target.x - transform.x;\r\n                const dy = playerInput.target.y - transform.y;\r\n                const dist = dSqrt(dx * dx + dy * dy);\r\n                const dirX = dist > 0 ? dx / dist : 0;\r\n                const dirY = dist > 0 ? dy / dist : 1;\r\n\r\n                const newRadius = sprite.radius / Math.SQRT2;\r\n\r\n                sprite.radius = newRadius;\r\n                body.radius = newRadius;\r\n\r\n                const clientIdStr = game.getClientIdString(clientId);\r\n                if (!clientIdStr) continue;\r\n\r\n                const newCell = spawnCell(game, clientIdStr, {\r\n                    x: transform.x + dirX * newRadius * 2,\r\n                    y: transform.y + dirY * newRadius * 2,\r\n                    radius: newRadius,\r\n                    color: colorStr,\r\n                    vx: dirX * SPLIT_VELOCITY,\r\n                    vy: dirY * SPLIT_VELOCITY\r\n                });\r\n\r\n                const mergeFrame = game.world.frame + MERGE_DELAY_FRAMES;\r\n                cellMergeFrame.set(cell.id, mergeFrame);\r\n                cellSplitFrame.set(cell.id, game.world.frame);\r\n                cellMergeFrame.set(newCell.id, mergeFrame);\r\n                cellSplitFrame.set(newCell.id, game.world.frame);\r\n            }\r\n        }\r\n    }, { phase: 'update' });\r\n\r\n    // Merge system\r\n    game.addSystem(() => {\r\n        const currentFrame = game.world.frame;\r\n        const playerCells = new Map<number, modu.Entity[]>();\r\n        const allCells = [...game.query('cell')].sort((a, b) => a.id - b.id);\r\n\r\n        for (const cell of allCells) {\r\n            if (cell.destroyed) continue;\r\n            const clientId = cell.get(modu.Player).clientId;\r\n            if (clientId === undefined || clientId === null) continue;\r\n            if (!playerCells.has(clientId)) playerCells.set(clientId, []);\r\n            playerCells.get(clientId)!.push(cell);\r\n        }\r\n\r\n        const sortedPlayers = [...playerCells.entries()].sort((a, b) =>\r\n            compareStrings(getClientIdStr(game, a[0]), getClientIdStr(game, b[0]))\r\n        );\r\n\r\n        for (const [, cells] of sortedPlayers) {\r\n            if (cells.length < 2) continue;\r\n\r\n            cells.sort((a, b) => {\r\n                const radiusDiff = b.get(modu.Sprite).radius - a.get(modu.Sprite).radius;\r\n                return radiusDiff !== 0 ? radiusDiff : a.id - b.id;\r\n            });\r\n\r\n            for (let i = 0; i < cells.length; i++) {\r\n                const cellA = cells[i];\r\n                if (cellA.destroyed) continue;\r\n\r\n                const tA = cellA.get(modu.Transform2D);\r\n                const sA = cellA.get(modu.Sprite);\r\n\r\n                for (let j = i + 1; j < cells.length; j++) {\r\n                    const cellB = cells[j];\r\n                    if (cellB.destroyed) continue;\r\n\r\n                    const mergeFrameA = cellMergeFrame.get(cellA.id) || 0;\r\n                    const mergeFrameB = cellMergeFrame.get(cellB.id) || 0;\r\n                    if (currentFrame < mergeFrameA || currentFrame < mergeFrameB) continue;\r\n\r\n                    const tB = cellB.get(modu.Transform2D);\r\n                    const sB = cellB.get(modu.Sprite);\r\n\r\n                    const dx = tA.x - tB.x;\r\n                    const dy = tA.y - tB.y;\r\n                    const dist = dSqrt(dx * dx + dy * dy);\r\n                    const mergeThreshold = (sA.radius + sB.radius) * 0.5;\r\n\r\n                    if (dist < mergeThreshold) {\r\n                        const areaA = sA.radius * sA.radius;\r\n                        const areaB = sB.radius * sB.radius;\r\n                        const newRadius = Math.min(dSqrt(areaA + areaB), MAX_RADIUS);\r\n\r\n                        sA.radius = newRadius;\r\n                        cellA.get(modu.Body2D).radius = newRadius;\r\n                        cellB.destroy();\r\n                        cellMergeFrame.delete(cellB.id);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }, { phase: 'update' });\r\n}\r\n\r\nexport function setupCollisions(game: modu.Game, physics: modu.Physics2DSystem): void {\r\n    // Cell eats food\r\n    physics.onCollision('cell', 'food', (cell, food) => {\r\n        if (food.destroyed) return;\r\n        const sprite = cell.get(modu.Sprite);\r\n        const foodSprite = food.get(modu.Sprite);\r\n        sprite.radius = Math.min(sprite.radius + foodSprite.radius * FOOD_GROW, MAX_RADIUS);\r\n        cell.get(modu.Body2D).radius = sprite.radius;\r\n        food.destroy();\r\n    });\r\n\r\n    // Cell eats smaller cell (different players only)\r\n    physics.onCollision('cell', 'cell', (cellA, cellB) => {\r\n        if (cellA.get(modu.Player).clientId === cellB.get(modu.Player).clientId) return;\r\n\r\n        const eaterSprite = cellA.get(modu.Sprite);\r\n        const preySprite = cellB.get(modu.Sprite);\r\n        if (eaterSprite.radius > preySprite.radius * EAT_RATIO) {\r\n            eaterSprite.radius = Math.min(eaterSprite.radius + preySprite.radius * PLAYER_GROW, MAX_RADIUS);\r\n            cellA.get(modu.Body2D).radius = eaterSprite.radius;\r\n            cellB.destroy();\r\n            cellMergeFrame.delete(cellB.id);\r\n        }\r\n    });\r\n}\r\n", "import { dSqrt } from 'modu-engine';\n/**\r\n * Cell Eater - Rendering & Camera\r\n */\r\n\r\nimport * as modu from 'modu-engine';\r\nimport { getPlayerCells } from './systems';\r\nimport {\r\n    WORLD_WIDTH,\r\n    WORLD_HEIGHT,\r\n    BASE_ZOOM,\r\n    MIN_ZOOM,\r\n    ZOOM_SCALE_FACTOR,\r\n    INITIAL_RADIUS,\r\n} from './constants';\r\n\r\nexport function lightenColor(hex: string, percent: number): string {\r\n    const num = parseInt(hex.slice(1), 16);\r\n    const r = Math.min(255, (num >> 16) + percent);\r\n    const g = Math.min(255, ((num >> 8) & 0x00FF) + percent);\r\n    const b = Math.min(255, (num & 0x0000FF) + percent);\r\n    return `rgb(${r},${g},${b})`;\r\n}\r\n\r\nexport function darkenColor(hex: string, percent: number): string {\r\n    const num = parseInt(hex.slice(1), 16);\r\n    const r = Math.max(0, (num >> 16) - percent);\r\n    const g = Math.max(0, ((num >> 8) & 0x00FF) - percent);\r\n    const b = Math.max(0, (num & 0x0000FF) - percent);\r\n    return `rgb(${r},${g},${b})`;\r\n}\r\n\r\nexport function worldToScreen(\r\n    worldX: number,\r\n    worldY: number,\r\n    camX: number,\r\n    camY: number,\r\n    camZoom: number,\r\n    WIDTH: number,\r\n    HEIGHT: number\r\n): { x: number; y: number } {\r\n    return {\r\n        x: (worldX - camX) * camZoom + WIDTH / 2,\r\n        y: (worldY - camY) * camZoom + HEIGHT / 2\r\n    };\r\n}\r\n\r\nexport function updateCamera(\r\n    game: modu.Game,\r\n    cameraEntity: modu.Entity,\r\n    getLocalClientId: () => number | null\r\n): void {\r\n    const localId = getLocalClientId();\r\n    if (localId === null) return;\r\n\r\n    const cells = getPlayerCells(game, localId);\r\n    if (cells.length === 0) return;\r\n\r\n    const camera = cameraEntity.get(modu.Camera2D);\r\n\r\n    let totalArea = 0;\r\n    let centerX = 0;\r\n    let centerY = 0;\r\n    let totalRadius = 0;\r\n\r\n    for (const cell of cells) {\r\n        const transform = cell.get(modu.Transform2D);\r\n        const sprite = cell.get(modu.Sprite);\r\n        const area = sprite.radius * sprite.radius;\r\n\r\n        centerX += transform.x * area;\r\n        centerY += transform.y * area;\r\n        totalArea += area;\r\n        totalRadius += sprite.radius;\r\n    }\r\n\r\n    if (totalArea > 0) {\r\n        centerX /= totalArea;\r\n        centerY /= totalArea;\r\n\r\n        camera.x += (centerX - camera.x) * camera.smoothing;\r\n        camera.y += (centerY - camera.y) * camera.smoothing;\r\n\r\n        const avgRadius = totalRadius / cells.length;\r\n        camera.targetZoom = Math.max(MIN_ZOOM, BASE_ZOOM - (avgRadius - INITIAL_RADIUS) * ZOOM_SCALE_FACTOR);\r\n\r\n        if (cells.length > 1) {\r\n            let maxDist = 0;\r\n            for (const cell of cells) {\r\n                const t = cell.get(modu.Transform2D);\r\n                const dist = dSqrt((t.x - centerX) ** 2 + (t.y - centerY) ** 2);\r\n                maxDist = Math.max(maxDist, dist);\r\n            }\r\n            const spreadZoom = Math.max(0.3, 1 - maxDist / 800);\r\n            camera.targetZoom = Math.min(camera.targetZoom, spreadZoom);\r\n        }\r\n\r\n        camera.zoom += (camera.targetZoom - camera.zoom) * camera.smoothing;\r\n    }\r\n}\r\n\r\nexport function createRenderer(\r\n    game: modu.Game,\r\n    renderer: modu.Simple2DRenderer,\r\n    cameraEntity: modu.Entity,\r\n    canvas: HTMLCanvasElement,\r\n    minimapCanvas: HTMLCanvasElement,\r\n    sizeDisplay: HTMLElement,\r\n    getLocalClientId: () => number | null\r\n): () => void {\r\n    const ctx = renderer.context;\r\n    const minimapCtx = minimapCanvas.getContext('2d')!;\r\n    const WIDTH = canvas.width;\r\n    const HEIGHT = canvas.height;\r\n\r\n    function renderMinimap(): void {\r\n        const camera = cameraEntity.get(modu.Camera2D);\r\n        const mmW = minimapCanvas.width;\r\n        const mmH = minimapCanvas.height;\r\n        const scaleX = mmW / WORLD_WIDTH;\r\n        const scaleY = mmH / WORLD_HEIGHT;\r\n\r\n        minimapCtx.fillStyle = 'rgba(17, 17, 17, 0.9)';\r\n        minimapCtx.fillRect(0, 0, mmW, mmH);\r\n\r\n        minimapCtx.strokeStyle = '#333';\r\n        minimapCtx.lineWidth = 1;\r\n        minimapCtx.strokeRect(0, 0, mmW, mmH);\r\n\r\n        for (const entity of game.getAllEntities()) {\r\n            if (entity.destroyed) continue;\r\n            try {\r\n                const sprite = entity.get(modu.Sprite);\r\n                if (!sprite || !sprite.visible) continue;\r\n\r\n                const transform = entity.get(modu.Transform2D);\r\n                const x = transform.x * scaleX;\r\n                const y = transform.y * scaleY;\r\n\r\n                const isFood = sprite.layer === 0;\r\n                const radius = isFood ? 1 : Math.max(3, sprite.radius * scaleX * 1.5);\r\n\r\n                const colorStr = game.getString('color', sprite.color) || '#fff';\r\n                minimapCtx.fillStyle = isFood ? 'rgba(255,255,255,0.3)' : colorStr;\r\n                minimapCtx.beginPath();\r\n                minimapCtx.arc(x, y, radius, 0, Math.PI * 2);\r\n                minimapCtx.fill();\r\n            } catch {}\r\n        }\r\n\r\n        const viewLeft = (camera.x - WIDTH / 2 / camera.zoom) * scaleX;\r\n        const viewTop = (camera.y - HEIGHT / 2 / camera.zoom) * scaleY;\r\n        const viewWidth = (WIDTH / camera.zoom) * scaleX;\r\n        const viewHeight = (HEIGHT / camera.zoom) * scaleY;\r\n\r\n        minimapCtx.strokeStyle = '#fff';\r\n        minimapCtx.lineWidth = 1;\r\n        minimapCtx.strokeRect(viewLeft, viewTop, viewWidth, viewHeight);\r\n\r\n        const localId = getLocalClientId();\r\n        if (localId !== null) {\r\n            const cells = getPlayerCells(game, localId);\r\n            for (const cell of cells) {\r\n                if (cell.destroyed) continue;\r\n                const transform = cell.get(modu.Transform2D);\r\n                const x = transform.x * scaleX;\r\n                const y = transform.y * scaleY;\r\n\r\n                minimapCtx.strokeStyle = '#fff';\r\n                minimapCtx.lineWidth = 2;\r\n                minimapCtx.beginPath();\r\n                minimapCtx.arc(x, y, 5, 0, Math.PI * 2);\r\n                minimapCtx.stroke();\r\n            }\r\n        }\r\n    }\r\n\r\n    return function renderWithCamera(): void {\r\n        const alpha = game.getRenderAlpha();\r\n        const camera = cameraEntity.get(modu.Camera2D);\r\n\r\n        updateCamera(game, cameraEntity, getLocalClientId);\r\n\r\n        let camX = camera.x, camY = camera.y;\r\n        const localId = getLocalClientId();\r\n        if (localId !== null) {\r\n            const cells = getPlayerCells(game, localId);\r\n            if (cells.length > 0) {\r\n                let totalArea = 0;\r\n                let centerX = 0;\r\n                let centerY = 0;\r\n\r\n                for (const cell of cells) {\r\n                    if (cell.destroyed || !cell.render) continue;\r\n                    cell.interpolate(alpha);\r\n                    const sprite = cell.get(modu.Sprite);\r\n                    const area = sprite.radius * sprite.radius;\r\n                    centerX += cell.render.interpX * area;\r\n                    centerY += cell.render.interpY * area;\r\n                    totalArea += area;\r\n                }\r\n\r\n                if (totalArea > 0) {\r\n                    camX = centerX / totalArea;\r\n                    camY = centerY / totalArea;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Clear canvas\r\n        ctx.fillStyle = '#f2f2f2';\r\n        ctx.fillRect(0, 0, WIDTH, HEIGHT);\r\n\r\n        ctx.save();\r\n        ctx.translate(WIDTH / 2, HEIGHT / 2);\r\n        ctx.scale(camera.zoom, camera.zoom);\r\n        ctx.translate(-camX, -camY);\r\n\r\n        // Draw grid\r\n        ctx.strokeStyle = '#e0e0e0';\r\n        ctx.lineWidth = 1 / camera.zoom;\r\n        const gridSize = 100;\r\n        const startX = Math.floor((camX - WIDTH / 2 / camera.zoom) / gridSize) * gridSize;\r\n        const startY = Math.floor((camY - HEIGHT / 2 / camera.zoom) / gridSize) * gridSize;\r\n        const endX = camX + WIDTH / 2 / camera.zoom;\r\n        const endY = camY + HEIGHT / 2 / camera.zoom;\r\n\r\n        for (let x = startX; x <= endX; x += gridSize) {\r\n            if (x >= 0 && x <= WORLD_WIDTH) {\r\n                ctx.beginPath();\r\n                ctx.moveTo(x, Math.max(0, startY));\r\n                ctx.lineTo(x, Math.min(WORLD_HEIGHT, endY));\r\n                ctx.stroke();\r\n            }\r\n        }\r\n        for (let y = startY; y <= endY; y += gridSize) {\r\n            if (y >= 0 && y <= WORLD_HEIGHT) {\r\n                ctx.beginPath();\r\n                ctx.moveTo(Math.max(0, startX), y);\r\n                ctx.lineTo(Math.min(WORLD_WIDTH, endX), y);\r\n                ctx.stroke();\r\n            }\r\n        }\r\n\r\n        // Draw world boundary\r\n        ctx.strokeStyle = '#ccc';\r\n        ctx.lineWidth = 4 / camera.zoom;\r\n        ctx.strokeRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);\r\n\r\n        // Collect and sort entities by layer\r\n        const entities: { entity: modu.Entity; layer: number }[] = [];\r\n        for (const entity of game.getAllEntities()) {\r\n            if (entity.destroyed) continue;\r\n            try {\r\n                const sprite = entity.get(modu.Sprite);\r\n                if (sprite && sprite.visible) {\r\n                    entity.interpolate(alpha);\r\n                    entities.push({ entity, layer: sprite.layer });\r\n                }\r\n            } catch {}\r\n        }\r\n        entities.sort((a, b) => a.layer - b.layer);\r\n\r\n        // Draw entities\r\n        for (const { entity } of entities) {\r\n            const sprite = entity.get(modu.Sprite);\r\n            const x = entity.render.interpX + sprite.offsetX;\r\n            const y = entity.render.interpY + sprite.offsetY;\r\n\r\n            const screenPos = worldToScreen(x, y, camX, camY, camera.zoom, WIDTH, HEIGHT);\r\n            const screenRadius = sprite.radius * camera.zoom;\r\n            if (screenPos.x + screenRadius < 0 || screenPos.x - screenRadius > WIDTH ||\r\n                screenPos.y + screenRadius < 0 || screenPos.y - screenRadius > HEIGHT) {\r\n                continue;\r\n            }\r\n\r\n            const colorStr = game.getString('color', sprite.color) || '#fff';\r\n\r\n            if (sprite.shape === modu.SHAPE_CIRCLE) {\r\n                const r = sprite.radius;\r\n                const isCell = sprite.layer === 1;\r\n\r\n                if (isCell && r > 10) {\r\n                    const gradient = ctx.createRadialGradient(x - r * 0.3, y - r * 0.3, 0, x, y, r);\r\n                    gradient.addColorStop(0, lightenColor(colorStr, 40));\r\n                    gradient.addColorStop(0.7, colorStr);\r\n                    gradient.addColorStop(1, darkenColor(colorStr, 20));\r\n\r\n                    ctx.fillStyle = gradient;\r\n                    ctx.beginPath();\r\n                    ctx.arc(x, y, r, 0, Math.PI * 2);\r\n                    ctx.fill();\r\n\r\n                    ctx.strokeStyle = darkenColor(colorStr, 30);\r\n                    ctx.lineWidth = Math.max(2, r * 0.08);\r\n                    ctx.stroke();\r\n\r\n                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';\r\n                    ctx.beginPath();\r\n                    ctx.arc(x - r * 0.25, y - r * 0.25, r * 0.25, 0, Math.PI * 2);\r\n                    ctx.fill();\r\n                } else {\r\n                    ctx.fillStyle = colorStr;\r\n                    ctx.beginPath();\r\n                    ctx.arc(x, y, r, 0, Math.PI * 2);\r\n                    ctx.fill();\r\n                }\r\n            }\r\n        }\r\n\r\n        ctx.restore();\r\n\r\n        renderMinimap();\r\n\r\n        // Update size display\r\n        if (localId !== null) {\r\n            const cells = getPlayerCells(game, localId);\r\n            const totalRadius = cells.reduce((sum, c) => sum + c.get(modu.Sprite).radius, 0);\r\n            sizeDisplay.textContent = `Size: ${Math.floor(totalRadius)}`;\r\n        }\r\n    };\r\n}\r\n"],
  "mappings": "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",
  "names": ["modu", "game", "modu", "game", "physics", "import_modu_engine", "modu", "WIDTH", "HEIGHT", "game", "cameraEntity", "getLocalClientId", "renderer", "canvas", "minimapCanvas", "sizeDisplay", "cam"]
}
